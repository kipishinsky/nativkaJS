////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Переменные Let, Const  Переменные Let, Const  Переменные Let, Const   Переменные Let, Const  Переменные Let, Const  Переменные Let, Const

// var - variable - переменная в глобальном маштабе
/*
var color = 'red'
console.log(color) // red
*/
// можем ее изменять, менять ей типы. делаем что угодно
/*
color = 'blue'
console.log(color) // blue
*/


// в es 6 получили 2 новых способа объявления переменных
// let работает точно так же как и var, но есть одна особенность
/*for (var i=0; i < 5; i++) {
    console.log(i) // 0 1 2 3 4
    setTimeout(function () {
        console.log(i) // получаем 5 раз 5ку. вопрос, почему без таймаута выдает нормальную итерацию, а с тайм аутом выдает 5 по 5
    }, 2000)
}*/
/* дело в следующем, когда мы создаем перменную через ключевое слово var,
     мы создаем переменную всего лишь один раз. создавая переменную один раз
     мы пробегаемся по циклу в синхронном формате и когда у нас происходит сет таймаут, тоесть
     выдерживается 2 ссекунды, JS уже успевает пробежаться по циклу до конца и
     переменная i становится = 5. данная проверка не проходит и цикл выходит из своего действия
     Но, сетТаймаут к этому времени еще не отрабатывает, когда проходит 2 сек он начинает
     делать консоль логи, но в параметр мы передаем не значение i, а ссылку на переменную i
     где ее значение равно 5 и поэтому вывводит 5 раз в консоль цифру 5. и это как бы не должно
     работать но работает. небольшие странности

 */
/*  если var изменить на let,
        то все будет работать корректно
 */

/*for (let i=0; i < 5; i++) {
    console.log(i) // 0 1 2 3 4
    setTimeout(function () {
        console.log(i) // 0 1 2 3 4
    }, 2000)
}*/
/*
Идея ключевого слова let, заключается в том, что
    данное ключевое слово работает только внутри блока, в котором оно было заданно.
    т.е. при пробегании цикла один раз, переменная i = 0 затирается новым значением 1
    и в консоль падает сначала 0, потом 0 затерся 1, потом 1 затерлась 2 и так до 4.
    как только i равняется 5, то блок не выполняется из за условия i < 5

    В этом и заключается основное отличие переменной let от var
*/



// переменная const
/*
переменная const не изменяется. но и у нее есть небольшая особенность
*/
/*
const hex = '#FFAABB'
hex = '#FFEEEEBB' // Uncaught TypeError: Assignment to constant variable.
document.querySelector('h1').style.color = hex
*/
/* изменить константу мы не смогли и у нас вылезла ошибка
    поэтому теперь всегда, когда мы видем ключевое слово const
    мы автоматически понимаем, что это переменная которая не может изменяться
*/
// теперь небольшая особенность
/*
const array = [1,2];
const obj = {a: 1};

array.unshift(4)
obj.b = 2


console.log(array) // [4, 1, 2]
console.log(obj) // {a: 1, b: 2}
*/
/*
Мы видим, что мы получили новые значения и в массиве и в объекте
    и все это проихошло не смотря на том, что мы задали все через ключевое слово const,
    где const(константа) по идее не должно изменяться.
    но смысл в том, что мы меняем значения массива и значение объекта (менять  внутреннюю структуру мы можем)

    Получается так, что мы не можем переприсвоить новое значение, например
    const obj = {a: 1}
    obj = 2 // ошибка
    Так мы сделать не можем. потому что в const obj лежит объект, а присваиваем мы ему число
    получается, что поменять содержимое объекта мы можем, а вот поменять тип переменной уже нет
*/
/*
    Вообще считается хорошим тоном, прописывать переменные через const
    Это указывает разработчикам на то, что переменная не изменит свой тип (как минимум)
    а в идеале и не будет изменять свое содержимое.

    Если нужно менять тип переменной, то используй let.
    Если нужно поменять только содержимое то const
    в остальных случаях всегда const
*/




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Стрелочные функции   Стрелочные функции   Стрелочные функции   Стрелочные функции   Стрелочные функции   Стрелочные функции   Стрелочные функции


// классическое объявление функции
function getAge (year) {
    const current = new Date().getFullYear()
    return current - year
}
console.log(getAge(1993)) //27


// Теперь стрелочная функция - она должна хранится в переменной. Такой синтаксис
const calculateAge = (year) => {
    const current = new Date().getFullYear()
    return current - year
}
console.log(calculateAge(1992)) // 28


// Различные вариации

// при указании одного параметра функции
const ageGet = year => { // если указывается один параметр, то можно не использовать скобки
    const current = new Date().getFullYear()
    return current - year
}
console.log(ageGet(1990)) // 30

// если функция записана в одну строчку, то можно не использовать {} и слово return
const getRange = year => new Date().getFullYear() - year
console.log(getRange(1980)) // 40

// так же можно прописывать так
const logAge = year => console.log(new Date().getFullYear() - year)
console.log(logAge(1945)) // 75

//
const person = {
    age:25,
    firstName: "Max",
    logNameWithTimeout: () => {
        setTimeout(() => {
            console.log(this.firstName)
        }, 1000)
    }
}
person.logNameWithTimeout() // undefined и через секунду undefined
/* undefined потому что this сейчас обращается к глобальному объекту window
        решить данную проблему можно через метод bind.
        но и даже если мы подставим bind(this)
            logNameWithTimeout: () => {
                setTimeout(function () {
                    console.log(this.firstName)
                }.bind(this), 1000)
            }
    то мы всеравно получим undefined, почему так происходит
    потому, что когда мы создаем функции через ключевое слово function то в функции
    автоматически создается определенный контекст. Стрелочная функция не создает свой собственный
    контекст и поэтому выдает undefined
*/
/*
 Чтобы решить данную проблему, то можно написать так
*/

const persona = {
    age:25,
    firstName: 'Max',
    logNameWithTimeout() {
        setTimeout(() => {
            console.log(this.firstName)
        }, 1000)
    }
}
persona.logNameWithTimeout() // undefined и через секунду Max
/*
    Мы прописывает метод не через функцию, или стрелочную функцию, а прописываем
    синтаксис как метод, который будет нести в себе контекст от метода, а дальше уже будет
    передаваться стрелочная функция. Это возможно внутри объектов или классов

*/

