////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Переменные Let, Const  Переменные Let, Const  Переменные Let, Const   Переменные Let, Const  Переменные Let, Const  Переменные Let, Const

// var - variable - переменная в глобальном маштабе
/*
var color = 'red'
console.log(color) // red
*/
// можем ее изменять, менять ей типы. делаем что угодно
/*
color = 'blue'
console.log(color) // blue
*/


// в es 6 получили 2 новых способа объявления переменных
// let работает точно так же как и var, но есть одна особенность
/*for (var i=0; i < 5; i++) {
    console.log(i) // 0 1 2 3 4
    setTimeout(function () {
        console.log(i) // получаем 5 раз 5ку. вопрос, почему без таймаута выдает нормальную итерацию, а с тайм аутом выдает 5 по 5
    }, 2000)
}*/
/* дело в следующем, когда мы создаем перменную через ключевое слово var,
     мы создаем переменную всего лишь один раз. создавая переменную один раз
     мы пробегаемся по циклу в синхронном формате и когда у нас происходит сет таймаут, тоесть
     выдерживается 2 ссекунды, JS уже успевает пробежаться по циклу до конца и
     переменная i становится = 5. данная проверка не проходит и цикл выходит из своего действия
     Но, сетТаймаут к этому времени еще не отрабатывает, когда проходит 2 сек он начинает
     делать консоль логи, но в параметр мы передаем не значение i, а ссылку на переменную i
     где ее значение равно 5 и поэтому вывводит 5 раз в консоль цифру 5. и это как бы не должно
     работать но работает. небольшие странности

 */
/*  если var изменить на let,
        то все будет работать корректно
 */

/*for (let i=0; i < 5; i++) {
    console.log(i) // 0 1 2 3 4
    setTimeout(function () {
        console.log(i) // 0 1 2 3 4
    }, 2000)
}*/
/*
Идея ключевого слова let, заключается в том, что
    данное ключевое слово работает только внутри блока, в котором оно было заданно.
    т.е. при пробегании цикла один раз, переменная i = 0 затирается новым значением 1
    и в консоль падает сначала 0, потом 0 затерся 1, потом 1 затерлась 2 и так до 4.
    как только i равняется 5, то блок не выполняется из за условия i < 5

    В этом и заключается основное отличие переменной let от var
*/



// переменная const
/*
переменная const не изменяется. но и у нее есть небольшая особенность
*/
/*
const hex = '#FFAABB'
hex = '#FFEEEEBB' // Uncaught TypeError: Assignment to constant variable.
document.querySelector('h1').style.color = hex
*/
/* изменить константу мы не смогли и у нас вылезла ошибка
    поэтому теперь всегда, когда мы видем ключевое слово const
    мы автоматически понимаем, что это переменная которая не может изменяться
*/
// теперь небольшая особенность
const array = [1,2];
const obj = {a: 1};

array.unshift(4)
obj.b = 2


console.log(array) // [4, 1, 2]
console.log(obj) // {a: 1, b: 2}
/*
Мы видим, что мы получили новые значения и в массиве и в объекте
    и все это проихошло не смотря на том, что мы задали все через ключевое слово const,
    где const(константа) по идее не должно изменяться.
    но смысл в том, что мы меняем значения массива и значение объекта (менять  внутреннюю структуру мы можем)

    Получается так, что мы не можем переприсвоить новое значение, например
    const obj = {a: 1}
    obj = 2 // ошибка
    Так мы сделать не можем. потому что в const obj лежит объект, а присваиваем мы ему число
    получается, что поменять содержимое объекта мы можем, а вот поменять тип переменной уже нет
*/

/*
    Вообще считается хорошим тоном, прописывать переменные через const
    Это указывает разработчикам на то, что переменная не изменит свой тип (как минимум)
    а в идеале и не будет изменять свое содержимое.

    Если нужно менять тип переменной, то используй let.
    Если нужно поменять только содержимое то const
    в остальных случаях всегда const
*/

